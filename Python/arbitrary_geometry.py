import numpy as np
import copy as cpy
import math
from fenics import *
import matplotlib.pyplot as plt
from fenics_mesh_tools import structured_cell_centroids, get_cell_centroids
from shapely.geometry import Polygon, Point as Pnt 
import itertools
import pandas as pd

def clockwiseangle_and_distance(point, origin = [0,0], refvec = [1,0]):
    # Vector between point and the origin: v = p - o
    vector = [point[0]-origin[0], point[1]-origin[1]]
    # Length of vector: ||v||
    lenvector = math.hypot(vector[0], vector[1])
    # If length is zero there is no angle
    if lenvector == 0:
        return -math.pi, 0
    # Normalize vector: v/||v||
    normalized = [vector[0]/lenvector, vector[1]/lenvector]
    dotprod  = normalized[0]*refvec[0] + normalized[1]*refvec[1]     # x1*x2 + y1*y2
    diffprod = refvec[1]*normalized[0] - refvec[0]*normalized[1]     # x1*y2 - y1*x2
    angle = math.atan2(diffprod, dotprod)
    # Negative angles represent counter-clockwise angles so we need to subtract them 
    # from 2*pi (360 degrees)
    if angle < 0:
        return 2*math.pi+angle, lenvector
    # I return first the angle because that's the primary sorting criterium
    # but if two vectors have the same angle then the shorter distance should come first.
    return angle, lenvector

def sort_clockwise(pts):

    """
    given a numpy array of boundary points of 
    a closed domain, this routine arranges the points
    in a clockwise fashion to from a closed ring
    (later to be used by shapely LinearRing )
    input:
    ------
        pts: np array of coordinates of boundary 
             vertices of a closed mesh generated by fenics
    output:

    """
    dim = 2
    center = pts.mean(axis=0)
    df = pd.DataFrame(pts)
    # Group points into quadrants
    df['quadrant'] = 0
    df.loc[(df[0] > center[0]) & (df[1] > center[1]), 'quadrant'] = 0
    df.loc[(df[0] > center[0]) & (df[1] < center[1]), 'quadrant'] = 1
    df.loc[(df[0] < center[0]) & (df[1] < center[1]), 'quadrant'] = 2
    df.loc[(df[0] < center[0]) & (df[1] > center[1]), 'quadrant'] = 3
    quadrant = {}
    x = 35;
    y = 5
    for i in range(4):
        quadrant[i] = df[df.quadrant == i]
        # Intelligently choose the quadrant centers
        subcenter = [[ x,  y ],
                     [ x, -y ],
                     [-x, -y],
                     [-x,  y]]
    # Compute the angle between each quadrant and respective center point
    angle = {}
    points = {}
    df_sub = {}
    for j in range(len(quadrant)):
        angle[j] = []
        points[j] = quadrant[j][[0,1]]
        for i in range(len(points[j])):
            ang, dist = clockwiseangle_and_distance(points[j].values[i,:] - subcenter[j], origin=[0,0], refvec=[1,0])
            angle[j].append(ang)
        
        df_sub[j] = quadrant[j]
        df_sub[j]['angle'] = np.degrees(angle[j])
        df_sub[j] = df_sub[j].sort_values(by='angle')

    # Combine the data frames
    df = pd.concat(df_sub)
    df['clockwise_order'] = np.arange(len(df))

    pts_sorted = np.zeros((len(pts), dim), dtype=float)
    pts_sorted[:,0] = df[0].to_numpy()
    pts_sorted[:,1] = df[1].to_numpy()
    
    #append the first point coordinate at the end to make a closed ring
    pts_sorted = np.append(pts_sorted, pts_sorted[0][None,:], axis=0)

    #reverse to make the points aligned in counterclockwise
    pts_sorted_rev = np.flip(pts_sorted, axis=0)
    return pts_sorted_rev


def intersect_mesh(src_msh, tgt_msh, struct_grd=True, plot_=True):
    """TODO: Docstring for intersect_mesh.
    This routine intersects src_msh with tgt_msh and 
    returns the cell centoids corresponding to tgt_msh

    This is particularly helpful if we want to create a 
    peridynamic particle of a complicated geometry in which
    the particles are uniformly distributed which cannot be
    created using fenics 

    :src_msh: fenics mesh object 
    :tgt_msh: fenics mesh
    struct_grd: boolean if we want structured grid 
    :plot_: boolean if we want to plot in the end 
    
    output:
    ------
        tgt_cell_cent:
        centroids of target mesh 

    """
    #get the boundary vertices of target mesh
    bmesh =  BoundaryMesh(tgt_msh, "exterior", True)
    bnd_coords = bmesh.coordinates()
    
    # make a counterclockwise closed ring from the 
    # points in bnd_coords 
    bnd_coords_arranged = sort_clockwise(bnd_coords)
    
    #convert to tuple, shapely works with tuple 
    bnd_coord_tuple = tuple(map(tuple, bnd_coords_arranged))
    
    #create a Shapely (library) polygon
    poly = Polygon(bnd_coord_tuple)

    if struct_grd:
        cell_cent = structured_cell_centroids(src_msh)
    else:
        cell_cent = get_cell_centroids(src_msh)
    #create tuple of cell_cent
    cell_cnt_tuple = tuple(map(tuple, cell_cent))
    
    idx_lst = []
    for cc in cell_cnt_tuple:
        pt = Pnt(cc)
        idx_lst.append(poly.contains(pt))
     
    idx_arr = np.array(idx_lst)
    idx = np.where(idx_arr == True)[0]

    tgt_cell_cent = cell_cent[idx]

    return tgt_cell_cent 


def unit_vector(vector):
    """ Returns the unit vector of the vector.  """
    return vector / np.linalg.norm(vector)

    
def get_bbox(cell_cent):
    """
    returns the bounding box of the array 
    of particle data 
    """

    dim = len(cell_cent[0])
    extents = np.zeros((2, dim), float)
    min_corners = np.zeros(dim, float)
    max_corners = np.zeros(dim, float)
    for d in range(dim):
        min_corners[d] = np.min(cell_cent[:,d])
        max_corners[d] = np.max(cell_cent[:,d])
        extents[0][d] = min_corners[d]
        extents[1][d] = max_corners[d]

    return extents

def get_bbox_range(bbox):
    """
    returns the difference of min and max along each 
    dimension in the bounding box
    """

    dim = len(bbox[0])
    box_range   = np.zeros(dim, float)
    for d in range(dim):
        box_range[d] = abs(bbox[0][d] - bbox[1][d])
    return box_range

def get_min_max_corners(bbox, dim):
    """

    """
    min_corners = min_corners = np.zeros(dim, float)
    max_corners = np.zeros(dim, float)
    corner_pts_in_each_dim = np.zeros((2, dim), dtype=float)

    for d in range(dim):
        min_corners[d] = bbox[0][d]
        max_corners[d] = bbox[1][d]
        corner_pts_in_each_dim[d] = bbox[:,d]
    return min_corners, max_corners, corner_pts_in_each_dim

def add_ghost_lyers(coords, bbox, num_lyrs):

    """
    input:
    ------
        coords: coordinates of arbitrary geometry
        bbox: domain bounding box
        num_lyrs: num layers
        
    """
    dim = len(bbox[0])
    min_corners, max_corners, corner_pts_in_each_dim = get_min_max_corners(bbox, dim)
    bbox_range = get_bbox_range(bbox)
    x_range = bbox_range[0]
    y_range = bbox_range[1]

    #create corners
    if dim == 2:
        x_corners = corner_pts_in_each_dim[0]
        y_corners = corner_pts_in_each_dim[1]
        corner_pts = np.array(np.meshgrid(x_corners, y_corners)).T.reshape(-1,dim) 

    if dim == 3:
       z_corners = corner_pts_in_each_dim[2]
       corner_pts = np.array(np.meshgrid(x_corners, y_corners, z_corners)).T.reshape(-1,dim)

    #get unique coordinates for y infaltion by deleting 
    #y coordinates lying on same x location 
    del_id1 = np.where(coords[:,0] == min_corners[0])
    del_id2 = np.where(coords[:,0] == max_corners[0])

    del_ids = np.zeros(0, dtype=int)
    del_ids = np.append(del_ids, del_id1)
    del_ids = np.append(del_ids, del_id2)

    coord_y_inflate = np.delete(coords, del_ids, axis=0)
    coord_y_inflate = np.append(coord_y_inflate, corner_pts, axis=0)

    #layer thickness for num lyrs
    inflate_factor = 0.2*num_lyrs
    #layer thickness for each lyrs
    fact = inflate_factor/num_lyrs

    new_lyrs = np.zeros((0, dim), dtype=float)
    for i in range(num_lyrs):
        j = i+1
        temp = cpy.deepcopy(coord_y_inflate)
        extents = get_bbox(coord_y_inflate)
        box_range = get_bbox_range(extents)
        temp[:,1] = temp[:,1]*(1+j*fact)
        new_lyrs = np.append(new_lyrs, temp, axis=0)
    
    bbox_range = get_bbox_range(new_lyrs)
    bbox_updated = get_bbox(new_lyrs)
    min_corners, max_corners, _ = get_min_max_corners(bbox_updated, dim)
    x_min_ids = np.where(coords[:,0] == min_corners[0])[0]
    x_max_ids = np.where(coords[:,0] == max_corners[0])[0]
    
    x_ids = np.concatenate((x_min_ids, x_max_ids), axis=0)
    coord_x_inflate = coords[x_ids]

    for i in range(num_lyrs):
        j = i+1
        temp = cpy.deepcopy(coord_x_inflate)
        temp[:,0] = temp[:,0]*(1+j*fact*0.2)
        new_lyrs = np.append(new_lyrs, temp, axis=0)

    return new_lyrs

def example_arbitrary_domain(struct_grd=False):
    """ 
    an example of pd mesh of an arbitrary domain
    """
    from fenics_mesh_tools import tensile_test_bar
    from fenics_mesh_tools import plot_peridym_mesh

    src_msh = RectangleMesh(Point(-110, -12), Point(110, 12), 200, 40)
    tgt_msh = tensile_test_bar()

    tgt_cell_cent = intersect_mesh(src_msh, tgt_msh, struct_grd=struct_grd)

    plot_peridym_mesh(cell_cent=tgt_cell_cent)
    
    pass
